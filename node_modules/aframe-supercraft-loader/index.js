var utils = require('./lib/utils');
require('../../src/components/geometry-merger');
require('../../src/components/super-environment');
require('../../src/components/super-environment-updater');
require('../../src/components/super-geometry');
require('../../src/components/super-material');

var fileLoader = new THREE.FileLoader();

/**
 * Load Supercraft scene.
 */
AFRAME.registerComponent('supercraft-loader', {
  schema: {
    includeEnvironment: {default: true},
    includeShadows: {default: true},
    name: {type: 'string'},
    src: {type: 'asset'},
  },

  init: function () {
    this.onLoad = this.onLoad.bind(this);
  },

  update: function () {
    var data = this.data;
    var el = this.el;
    var url;

    if (!data.src && !data.name) { return; }

    if (data.includeShadows) { el.setAttribute('shadow', ''); }

    url = data.name
      ? 'https://supercraftsite.s3-us-west-2.amazonaws.com/' + data.name
      : data.src;

    // From URL.
    el.setAttribute('geometry-merger', 'isParentMerger', true);
    el.setAttribute('super-material', '');
    fileLoader.load(url, data => {
      this.generate(JSON.parse(data));
      waitForChildrenLoaded(el, this.onLoad);
    });
  },

  generate: function (data) {
    var el = this.el;
    var preset;
    var thingData;
    var thingEl;
    var thingId;
    var shapeData
    var shapeEl
    var shapeId;

    if (this.data.includeEnvironment) {
      preset = data.environment
        ? (data.environment.presetColor || data.environment.preset)
        : 'teal';
      el.setAttribute('super-environment-updater', {preset: preset});
    }

    for (thingId in data.entities) {
      // Create entity.
      thingData = data.entities[thingId];
      thingEl = utils.createThing(thingData);
      el.appendChild(thingEl);
    }
  },

  onLoad: function () {
    this.el.emit('supercraftloaderloaded');
  }
});

/**
 * Loader that inserts shapes over time, visualizing the creation process.
 */
AFRAME.registerComponent('supercraft-visualizer', {
  schema: {
    autoplay: {default: false},
    deprioritizeThings: {type: 'array'},
    dur: {default: 2000},
    name: {type: 'string'},
    prioritizeThings: {type: 'array'},
    src: {type: 'asset'}
  },

  init: function () {
    this.queueThing = this.queueThing.bind(this);

    this.currentIndex = 0;
    this.entityIndex = {};
    this.isPlaying = false;
    this.isLoaded = false;
    this.shapes = [];
    this.start = false;
    this.thingEls = {};
    this.thingIds = [];
    this.time = undefined;

    this.el.addEventListener('supercraftvisualizerstart', () => {
      this.reset();
      this.start = true;
    });
  },

  update: function (oldData) {
    var data = this.data;
    var el = this.el;
    var url;

    // Re-analyze with updated duration.
    if (this.sData && oldData.dur !== data.dur) {
      this.setData(this.sData);
    }

    if (!data.src && !data.name) { return; }

    el.setAttribute('shadow', '');

    url = data.name
      ? 'https://supercraftsite.s3-us-west-2.amazonaws.com/' + data.name
      : data.src;

    // From URL.
    fileLoader.load(url, data => {
      var sData = JSON.parse(data);
      this.createEnvironment(sData);
      this.setData(sData);
    });
  },

  createEnvironment: function (sData) {
    var preset;
    preset = sData.environment
      ? (sData.environment.presetColor || sData.environment.preset)
      : 'teal';
    this.el.sceneEl.setAttribute('super-environment-updater', {preset: preset});
  },

  setData: function (sData) {
    var thingId;
    var shapeId;

    this.sData = sData;

    // Create entity index.
    for (thingId in sData.entities) {
      this.entityIndex[thingId] = sData.entities[thingId];
      for (shapeId in sData.entities[thingId].shapes) {
        this.entityIndex[shapeId] = sData.entities[thingId].shapes[shapeId];
      }
    }

    // Get thing IDs, sorted.
    for (thingId in sData.entities) {
      if (this.data.deprioritizeThings.indexOf(thingId) !== -1) { continue; }
      this.thingIds.push(thingId);
    }
    this.thingIds.sort((a, b) => {
      if (a < b) { return -1; }
      if (a === b) { return 0; }
      if (a > b) { return 1; }
    });

    // Allow rendering some things first.
    this.data.prioritizeThings.forEach(this.queueThing);
    // Generate shape array.
    this.thingIds.forEach(this.queueThing);
    // Allow rendering some things last.
    this.data.deprioritizeThings.forEach(this.queueThing);

    // Calculate time offset per shape.
    this.offset = this.data.dur / this.shapes.length;

    if (this.data.autoplay) { this.start = true; }

    this.isLoaded = true;
  },

  queueThing: function (thingId) {
    var shapeId;
    var thing;
    thing = this.entityIndex[thingId];
    for (shapeId in thing.shapes) {
      if (this.shapes.indexOf(thing.shapes[shapeId]) !== -1) { continue; }
      this.shapes.push(this.entityIndex[shapeId]);
    }
  },

  renderShape: function (index) {
    var shape
    var thingEl;
    shape = this.shapes[index];

    // Create Thing if not yet created.
    thingEl = this.thingEls[shape.parentId];
    if (!thingEl) {
      thingEl = utils.createEntity(this.entityIndex[shape.parentId].attributes);
      this.thingEls[shape.parentId] = thingEl;
      this.el.appendChild(thingEl);
    }

    // Create Shape.
    thingEl.appendChild(utils.createEntity(shape.attributes));
  },

  reset: function () {
    this.currentIndex = 0;
    this.el.innerHTML = '';
    this.thingEls = {};
    this.time = undefined;
  },

  tick: function (time, timeDelta) {
    // Wait for start flag and JSON analyze before starting.
    if (this.start && this.isLoaded) {
      this.isPlaying = true;
      this.start = false;
      this.time = 0;
      return;
    }

    if (!this.isPlaying) { return; }

    this.time += timeDelta;
    while (this.time > (this.currentIndex * this.offset)) {
      if (this.currentIndex >= this.shapes.length) {
        this.isPlaying = false;
        return;
      }
      this.renderShape(this.currentIndex);
      this.currentIndex++;
    }
  }
});

function waitForChildrenLoaded (el, cb) {
  var i;
  var loaded = 0;

  for (i = 0; i < el.children.length; i++) {
    if (el.children[i].hasLoaded) {
      loaded++;
      continue;
    }
    el.children[i].addEventListener('loaded', childLoaded);
  }

  function childLoaded (evt) {
    loaded++;
    if (loaded === el.children.length) { cb(); }
  }
}
